import numpy as np
from scipy.stats import cauchy, random_correlation as _random_correlation
from programs.orthant_proba.model import order_variable, generate_Sigma_and_a, standardized_Gamma_and_a
import scipy.sparse as sparse
from scipy.linalg import block_diag

#=== Problems generators ===
def Ridgway_generator(d, seed, cpam):
    np.random.seed(seed)
    X = cauchy.rvs(scale=cpam, size=(d,d))
    a = cauchy.rvs(scale=cpam, size=d)
    Sigma = X.T @ X
    normalizer = np.diag(1/np.sqrt(np.diag(Sigma)))
    Sigma = normalizer @ Sigma @ normalizer
    a = normalizer @ a
    return Sigma, a

def tri_diag_generator(d, seed, rho, M):
    np.random.seed(seed)
    Gamma = sparse.diags([1, -rho], [0, -1], (d, d)).toarray()
    a = np.array([-rho] + [rho * M] * (d - 1))
    Sigma = Gamma @ Gamma.T
    return Sigma, a

def perturbed_translated_generator(seed, pscale, tvector, svector):
    """
    Generate an orthant probability problem corresponding to the probability of a d-dimension standard normal falling in the cone generated by d vectors and translated by `tvector`. The `d` generators are the source vector and other `d-1` vectors produced by perturbing the former with the degree of perturbation defined by `pscale`.
    This function can be used alone to create difficult orthant probability problems, or to be used in a higher dimensinon problem by creating blocks of difficult lower dimension problems.
    :param pscale: perturbation scale
    :param tvector: translation vector
    :param svector: source vector
    """
    np.random.seed(seed)
    d = len(svector)
    V = np.linalg.inv(np.random.normal(scale=pscale,size=(d,d)) + svector).T
    return V @ V.T, V@tvector

def blocked_generator(seed, base_Sigma, base_a, repeat, noise):
    np.random.seed(seed)
    Sigma = block_diag(*(base_Sigma,)*repeat)
    noise_matrix = np.random.normal(scale=noise, size=Sigma.shape)
    noise_matrix = noise_matrix @ noise_matrix.T
    Sigma = Sigma+ noise_matrix
    a = np.array(list(base_a)*repeat)
    return Sigma,a

def negative_corr(rho, d, a):
    Sigma = np.zeros((d,d)) - rho + np.diag([1+rho]*d)
    a = np.array([a]*d)
    return Sigma, a

def random_correlation(d, a, seed):
    np.random.seed(seed)
    eigs = np.diff(sorted(np.r_[0, np.random.rand(d - 1), 1])) * d
    assert np.allclose(sum(eigs), d) and len(eigs) == d
    return _random_correlation.rvs(eigs), np.array([a] * d)

def Miwa_and_Craig_toy_example(d):
    """
    An easy orthant probability problem whose exact value is known (1/(d+1)).
    """
    return np.zeros((d,d)) + 1/2 + 1/2 * np.identity(d), np.zeros(d)

#=== Saver ===
def optimize_and_save(Sigma, a, name, reorder=True, verify_numerical_stabilities=True):
    if reorder:
        Sigma, a = order_variable(Sigma=Sigma, a=a)
    if verify_numerical_stabilities:
        with np.errstate(divide='raise', over='raise', under='ignore', invalid='raise'):
            standardized_Gamma_and_a(Sigma, a)
    np.save(file='./programs/orthant_proba/data/Sigma_' + name, arr=Sigma)
    np.save(file='./programs/orthant_proba/data/a_' + name, arr=a)

#=== Dummy commands to produce files ===
def Ridgway_50_001():
    Sigma, a = Ridgway_generator(d=50, seed=1, cpam=0.01)
    optimize_and_save(Sigma, a, name='ridgway_50_001')

def dummy_problem():
    np.random.seed(4231)
    Sigma, a = generate_Sigma_and_a(d=6, low=-1, high=3)
    optimize_and_save(Sigma, a, name='dummy')

def negcor50():
    Sigma, a = negative_corr(rho=1/49/1.05, d=50, a=7)
    optimize_and_save(Sigma, a, name='negcor50')

def negcor70():
    Sigma, a = negative_corr(rho=1/69/1.03, d=70, a=7)
    optimize_and_save(Sigma, a, name='negcor70', reorder=False)

def rc100():
    Sigma, a = random_correlation(d=100, a=1.5, seed=4321)
    optimize_and_save(Sigma, a, 'rc100')

def rc200():
    Sigma, a = random_correlation(d=200, a=1.5, seed=4321)
    optimize_and_save(Sigma, a, 'rc200')

def rc50():
    Sigma, a = random_correlation(d=50, a=1.5, seed=5092)
    optimize_and_save(Sigma, a, 'rc50')

def rc150():
    Sigma, a = random_correlation(d=150, a=1.5, seed=4321)
    optimize_and_save(Sigma, a, 'rc150')

def rc20():
    Sigma, a = random_correlation(d=20, a=1.5, seed=5092)
    optimize_and_save(Sigma, a, 'rc20')